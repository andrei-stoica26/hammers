---
title: "hammers"
author: "Andrei-Florian Stoica"
package: hammers
date: November 2, 2025
output: BiocStyle::html_document
vignette: >
    %\VignetteIndexEntry{Getting started with CSOA}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

`hammers` is a utilities suite for scRNA-seq data analysis and package 
development. It offers functions (both getters and setters) that can operate 
on both Seurat and SingleCellExperiment objects, intended to help 
developers build tools compatible with both types of input. Additionally, 
`hammers` provides simple tools to address tasks in scRNA-seq data analysis, 
such as retrieving aggregate gene statistics, finding and removing rare genes, 
performing multiple testing correction, computing the center of mass for the 
expression of a gene of interest in low-dimensional space, and calculating 
silhouette and cluster-normalized silhouette.

# Installation

To install hammers, run the following commands in an R session:

```{r setup, eval=FALSE}
if (!require("BiocManager", quietly=TRUE))
    install.packages("BiocManager")

BiocManager::install("hammers")
```

# Prerequisites
In addition to hammers, you need to install [scater](https://bioconductor.org/packages/release/bioc/html/scater.html)and [scRNAseq](https://bioconductor.org/packages/release/data/experiment/html/scRNAseq.html)
for this tutorial.

# Loading data

This tutorial uses an scRNA-seq human pancreas dataset. After loading the 
required packages, download the dataset using the `BaronPancreasData` function 
from `scRNAseq`. The dataset will be stored as a SingleCellExperiment object. 

```{r message=FALSE, warning=FALSE, results=FALSE}
library(hammers)
library(scRNAseq)
library(scater)
library(Seurat)

sceObj <- BaronPancreasData('human')
```

# Providing compatibility between Seurat and SingleCellExperiment objects

To illustrate this functionality of hammers, we will first normalize and 
log-transform the data using the `logNormCounts` function from `scuttle` 
(loaded automatically with `scater`).

```{r message=FALSE, warning=FALSE, results=FALSE}
sceObj <- logNormCounts(sceObj)
```

We will also need PCA and UMAP dimensions. These can be computed using the 
`runPCA` and `runUMAP` functions from `scater`:

```{r message=FALSE, warning=FALSE, results=FALSE}
sceObj <- runPCA(sceObj)
sceObj <- runUMAP(sceObj)
```

Now we will convert the dataset to a Seurat object:

```{r message=FALSE, warning=FALSE, results=FALSE}
seuratObj <- as.Seurat(sceObj)
```

Next, we will introduce the `scExpMat` function, which extracts the expression
matrix from a Seurat or SingleCellExperiment object.

```{r message=FALSE, warning=FALSE}
mat1 <- scExpMat(sceObj)
dim(mat1)
mat2 <- scExpMat(seuratObj)
identical(mat1, mat2)
```

By default, the function extracts normalized and log-transformed single-cell
expression data, so it looks for the `data` assay for a Seurat object and for
the `logcounts` assay for a SingleCellExperiment object. This behavior can be
changed by setting the `dataType` parameter to `counts`â€”in which case the
function will look for an assay with this name in the input object.

`scExpMat` can also take a matrix as an argument. This option is useful when 
building functions allowing users to use either a single-cell expression matrix 
or an object of a dedicated class (Seurat, SingleCellExperiment) as input:

```{r}
mat2 <- scExpMat(mat1)
identical(mat1, mat2)
```

By default, `scExpMat`converts the expression matrix to a dense matrix. 
If this behavior is not desired, conversion can be skipped by setting `densify`
to `FALSE`:

```{r}
is(mat1)[1]
mat2 <- scExpMat(sceObj, densify=FALSE)
is(mat2)[2]
```

`scExpMat`can also extract the expression data only for selected genes:

```{r}
mat2 <- scExpMat(sceObj, genes=rownames(sceObj)[seq(30, 80)])
dim(mat2)
```

The `scCol` function extracts a column from the metadata of the Seurat object 
or the coldata of the SingleCellExperiment object:

```{r}
col1 <- scCol(seuratObj, 'label')
col2 <- scCol(sceObj, 'label')
identical(col1, col2)
head(col1)
```

It can also be used to insert a new column. Here, we just make a modified
copy of the `label` column for the Seurat object:

```{r}
scCol(seuratObj, 'labelCopy') <- paste0(scCol(seuratObj, 'label'), '_copy')
head(seuratObj[['labelCopy']])
```

The `metadataDF` function extracts the metadata/coldata data frame from a
Seurat or SingleCellExpression object:

```{r}
df1 <- metadataDF(seuratObj)
df2 <- metadataDF(sceObj)
identical(df1, df2)
head(df1)[, c(1, 2)]
```

The `metadataNames` function extracts the column names of the metadata/coldata 
data frame from a Seurat or SingleCellExpression object:

```{r}
colNames1 <- metadataNames(seuratObj)
colNames2 <- metadataNames(sceObj)
identical(colNames1, colNames2)
head(colNames1)
```

**Note**: Just like `scCol`, the `metadataDF` and `metadataNames` functions 
allow users to alter the value of the stored objects.

The scColCounts and scColPairCounts functions are wrappers around 
`dplyr::count` and enable counting frequencies of elements from one or two 
categorical columns in a Seurat or SingleCellExpression object:

```{r}
freq1 <- scColCounts(sceObj, 'donor')
freq2 <- scColCounts(seuratObj, 'donor')
identical(freq1, freq2)
head(freq1)
freq1 <- scColPairCounts(sceObj, 'donor', 'label')
freq2 <- scColPairCounts(seuratObj, 'donor', 'label')
identical(freq1, freq2)
head(freq1)
```

The `distributionPlot` function calls `scColPairCounts` in order to plot
the frequencies of elements from two categorical columns:

```{r}
distributionPlot(sceObj, NULL, 'donor', 'label')
```

# Extracting gene information

The `genePresence` function extracts the `genes` that appear in at 
least `minCutoff` and at most `maxCutoff` cells. It returns a data frame 
listing the number of cells in which each gene meeting these criteria is 
expressed:

```{r}
df <- genePresence(sceObj, rownames(sceObj)[seq(100)], 300, 2000)
dim(df)
head(df)
```

The `geneCellSets` function lists all the cells in which selected genes are 
expressed:

```{r}
cellSets <- geneCellSets(sceObj, rownames(sceObj)[seq(100)])
head(cellSets[[1]])
```

`findRareGenes` is a wrapper around `genePresence` that can extract the
genes that appear in at least `nCells` cells:

```{r}
df <- findRareGenes(sceObj, 10)
dim(df)
head(df)
```

The `removeRareGenes` function calls `findRareGenes` and subsequently removes
the identified rare genes from the object:

```{r}
dim(sceObj)
sceObj <- removeRareGenes(sceObj, 10)
dim(sceObj)
```

# Representation analysis and multiple testing

The `repAnalysis` function shows which pairs selected from two categorical 
columns of a single-cell object are:

- Statistically overrepresented. This is the default setting.
- Statistically underrepresented. This requires setting `doOverrep` to `FALSE`.

```{r}
df <- repAnalysis(sceObj, 'donor', 'label')
head(df)
head(repAnalysis(sceObj, 'donor', 'label', doOverrep=FALSE))
```

`repAnalysis` relies upon the `mtCorrectDF` function for multiple testing.
By default, `repAnalysis` calls `mtCorrectDF` with the `mtMethod` parameter 
set to `by` (Benjamini-Yekutieli). Other options are `bf` (Bonferroni) and 
`bh` (Benjamini-Hochberg):

```{r}
head(repAnalysis(sceObj, 'donor', 'label', mtMethod='bf'))
head(repAnalysis(sceObj, 'donor', 'label', mtMethod='bh'))
```

The output of `repAnalysis` can be visualized using the `pvalRiverPlot` 
function. Thicker connecting bands represent lower p-values:

```{r}
pvalRiverPlot(df, title=NULL)
```

**Note**: `pvalRiverPlot` can create an alluvial plot for any data frame
with a p-value column.

# Computing centers of mass

Given a list of genes, `geneCenters` can compute the center of mass of each
gene based on a dimensionality reduction of choice. By default, the reduction used by 
`geneCenters` is UMAP:

```{r}
genes <- c('PRSS1', 'TTR', 'GJD2', 'MS4A8')
geneCenters(sceObj, genes)
```

The centers of mass can be visualized with `genesDimPlot`, a wrapper around
the `DimPlot` function from `Seurat`. `genesDimPlot` uses `geneCenters` 
internally:

```{r}
genesDimPlot(seuratObj, genes, group.by='label')
```

**Note**: The related `colsDimPlot` function can plot the center of mass of
numeric columns of the metadata of a Seurat object. `colsDimPlot` uses 
`colCenters` internally, which works similarly to `geneCenters`. Both 
`genesDimPlot` and `colsDimPlot` are wrappers around `pointsDimPlot`, which
adds labeled points on a plot generated with `Seurat::DimPlot`.

# Computing silhouette and normalized silhouette

The `computeSilhouette` computes the silhouette for an input column in the
metadata or coldata of the single-cell expression object, returning the object
with an appended silhouette column:

```{r}
sceObj <- computeSilhouette(sceObj, 'label', 'labelSil')
head(scCol(sceObj, 'labelSil'))
```

The `normalizeSilhouette` function returns a data frame whose number of rows
equals the number of cells and the number of columns equals the number of 
identities in the single-cell expression object. It requires silhouette 
information for the required column to be provided in the metadata/coldata of 
the object. 

For each column in the output data frame, cells outside of the 
corresponding identity get a score of 0. All the other cells get scores in
(0, 1] by adjusted min-max normalization:

```{r}
df <- normalizeSilhouette(sceObj, 'label', 'labelSil')
head(df)
```

# Session information {-}
```{r}
sessionInfo()
```

