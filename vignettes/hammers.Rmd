---
title: "hammers"
author: "Andrei-Florian Stoica"
package: hammers
date: October 9, 2025
output: BiocStyle::html_document
vignette: >
    %\VignetteIndexEntry{Getting started with CSOA}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

`hammers` is a utilities suite for scRNA-seq data analysis and package 
development. It offers functions—getters and setters—that can equally operate 
on `Seurat` and `SingleCellExperiment` objects, intended to help 
developers build tools compatible with both types of input. Additionally, 
`hammers` provides simple tools to address tasks in scRNA-seq data analysis, 
such as retrieving aggregate gene statistics, finding and removing rare genes, 
performing multiple testing correction, computing the center of mass for the 
expression of a gene of interest in low-dimensional space, and calculating 
silhouette and cluster-normalized silhouette.

# Installation

To install hammers, run the following commands in an R session:

```{r setup, eval=FALSE}
if (!require("BiocManager", quietly=TRUE))
    install.packages("BiocManager")

BiocManager::install("hammers")
```

# Prerequisites
In addition to hammers, you need to install [scater](https://bioconductor.org/packages/release/bioc/html/scater.html)and [scRNAseq](https://bioconductor.org/packages/release/data/experiment/html/scRNAseq.html)
for this tutorial.

# Loading data

This tutorial uses an scRNA-seq human pancreas dataset. After loading the 
required packages, download the dataset using the `BaronPancreasData` function 
from `scRNAseq`. The dataset will be stored as a `SingleCellExperiment` object. 

```{r message=FALSE, warning=FALSE, results=FALSE}
library(hammers)
library(scRNAseq)
library(scater)
library(Seurat)

sceObj <- BaronPancreasData('human')
```

# Providing compatibility between Seurat and SingleCellExperiment objects

To illustrate this functionality of hammers, we will first normalize and 
log-transform the data using the `logNormCounts` function from `scuttle` 
(loaded automatically with `scater`).

```{r message=FALSE, warning=FALSE, results=FALSE}
sceObj <- logNormCounts(sceObj)
```

We will also need PCA and UMAP dimensions. These can be computed using the 
`runPCA` and `runUMAP` functions from `scater`:

```{r message=FALSE, warning=FALSE, results=FALSE}
sceObj <- runPCA(sceObj)
sceObj <- runUMAP(sceObj)
```

Now we will convert the dataset to a Seurat object:

```{r message=FALSE, warning=FALSE, results=FALSE}
seuratObj <- as.Seurat(sceObj)
```

Next, we will introduce the `scExpMat` function, which extracts the expression
matrix from a Seurat or SingleCellExperiment object.

```{r message=FALSE, warning=FALSE}
mat1 <- scExpMat(sceObj)
dim(mat1)
mat2 <- scExpMat(seuratObj)
identical(mat1, mat2)
```

By default, the function extracts normalized and log-transformed single-cell
expression data, so it looks for the `data` assay for a Seurat object and for
the `logcounts` one for a SingleCellExperiment object. This behavior can be
changed by setting the `dataType` parameter to `counts`.

`scExpMat` can also take a matrix as an argument. This option is useful when 
building functions allowing users to use either a single-cell expression matrix 
or an object of a dedicated class (Seurat, SingleCellExperiment) as input:

```{r}
mat2 <- scExpMat(mat1)
identical(mat1, mat2)
```

By default, `scExpMat`converts the expression matrix to a dense matrix. 
If this behavior is not desired, conversion can be skipped by setting `densify`
to `FALSE`:

```{r}
is(mat1)[1]
mat2 <- scExpMat(sceObj, densify=FALSE)
is(mat2)[2]
```

`scExpMat`can also extract the expression data only for selected genes:

```{r}
mat2 <- scExpMat(sceObj, genes=rownames(sceObj)[seq(30, 80)])
dim(mat2)
```

The `scCol` function extracts a column from the metadata of the `Seurat` object 
or the coldata of the `SingleCellExperiment` object:

```{r}
col1 <- scCol(seuratObj, 'label')
col2 <- scCol(sceObj, 'label')
identical(col1, col2)
head(col1)
```

It can also be used to insert a new column. Here, we just make a modified
copy of the `label` column for the `Seurat` object:

```{r}
scCol(seuratObj, 'labelCopy') <- paste0(scCol(seuratObj, 'label'), '_copy')
head(seuratObj[['labelCopy']])
```

The `metadataDF` function extracts the metadata/coldata data frame from a
`Seurat` or `SingleCellExpression` object:

```{r}
df1 <- metadataDF(seuratObj)
df2 <- metadataDF(sceObj)
identical(df1, df2)
head(df1)[, c(1, 2)]
```

The `metadataNames` function extracts the column names of the metadata/coldata 
data frame from a `Seurat` or `SingleCellExpression` object:

```{r}
colNames1 <- metadataNames(seuratObj)
colNames2 <- metadataNames(sceObj)
identical(colNames1, colNames2)
head(colNames1)
```

**Note**: Just like `scCol`, the `metadataDF` and `metadataNames` functions 
allow users to alter the value of the stored objects.

The`scColCounts` and `scColPairCounts` functions are wrappers around 
`dplyr::count` which enable counting frequencies of elements from one or two 
categorical columns in a `Seurat` or `SingleCellExpression` object:

```{r}
freq1 <- scColCounts(sceObj, 'donor')
freq2 <- scColCounts(seuratObj, 'donor')
identical(freq1, freq2)
head(freq1)
freq1 <- scColPairCounts(sceObj, 'donor', 'label')
freq2 <- scColPairCounts(seuratObj, 'donor', 'label')
identical(freq1, freq2)
head(freq1)
```

The `distributionPlot` function calls `scColPairCounts` in order to plot
the frequencies of elements from two categorical columns:

```{r}
distributionPlot(sceObj, NULL, 'donor', 'label')
```

# Extracting gene information

The `genePresence` function extracts the `genes` that appear in at 
least `minCutoff` and at most `maxCutoff` cells. It returns a data frame 
listing the number of cells in which each gene meeting these criteria is 
expressed:

```{r}
df <- genePresence(sceObj, rownames(sceObj)[seq(100)], 300, 2000)
dim(df)
head(df)
```

The `geneCellSets` function lists all the cells in which selected genes are 
expressed:

```{r}
cellSets <- geneCellSets(sceObj, rownames(sceObj)[seq(100)])
head(cellSets[[1]])
```

`findRareGenes` is a wrapper around `genePresence` that can extract the
genes that appear in at least `nCells` cells:

```{r}
df <- findRareGenes(sceObj, 10)
dim(df)
head(df)
```

The `removeRareGenes` function calls `findRareGenes` and subsequently removes
the identified rare genes from the single-cell expression object:

```{r}
dim(sceObj)
sceObj <- removeRareGenes(sceObj, 10)
dim(sceObj)
```

# Representation analysis and multiple testing

The `repAnalysis` function shows which pairs selected from two categorical 
columns of a single-cell object are:

- Statistically overrepresented. This is the default setting.
- Statistically underrepresented. This requires setting `doOverrep` to `FALSE`.

```{r}
df <- repAnalysis(sceObj, 'donor', 'label')
head(df)
head(repAnalysis(sceObj, 'donor', 'label', doOverrep=FALSE))
```

`repAnalysis` relies upon the `mtCorrectDF` function for multiple testing.
By default, `repAnalysis` calls `mtCorrectDF` with the `mtMethod` parameter 
set to `by` (Benjamini-Yekutieli). Other options are `bf` (Bonferroni) and 
`bh` (Benjamini-Hochberg):

```{r}
head(repAnalysis(sceObj, 'donor', 'label', mtMethod='bf'))
head(repAnalysis(sceObj, 'donor', 'label', mtMethod='bh'))
```

The output of `repAnalysis` can be visualized using the `pvalRiverPlot` 
function. Thicker connecting bands represent lower p-values:

```{r}
pvalRiverPlot(df, title=NULL)
```

**Note**: `pvalRiverPlot` can create an alluvial plot for any data frame
with a p-value column.
